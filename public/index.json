[{"content":" An image can be broken down into two components: the Chroma (Color) and the Luma (Brightness). if we desaturate an image completely (remove color), what is left is the Grayscaled version of that image. some people might refer to grayscale as \u0026ldquo;black and white\u0026rdquo;, however that\u0026rsquo;s not a technically accurate term for that. black and white would suggest that all the pixels of the image is either black or white, the image would be made of only 2 colors (Binary Image). a grayscale image on the other hand could be made of 50 shades of gray (usually much more).\nHow It Works? To grayscale the screen our fragment shader runs for every pixel and replace the color with a shade of gray that represents the brightness of that pixel.\nThe Recipe Add a new ColorRect and make it Fullscreen and add a new ShaderMaterial to it and create a new shader for it(See How).\na new shader looks like this:\nshader_type canvas_item; void fragment() { // Place fragment code here. } Step 1: Sample The Color our grayscale shader needs to read the screen, we do that like so:\nshader_type canvas_item; uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap; void fragment() { vec4 pixelColor = texture(SCREEN_TEXTURE, SCREEN_UV); } we add a uniform calledSCREEN_TEXTURE(you can call it anything you like).\nThe uniform declaration forSCREEN_TEXTUREincludes two hints:hint_screen_textureandfilter_linear_mipmap. hint_screen_texturetells Godot that this uniform should be automatically set to the screen texture, andfilter_linear_mipmapspecifies that the texture should be filtered using linear interpolation and mipmapping. These hints help ensure that the screen texture is sampled correctly and efficiently in the shader.\nwe then sample theSCREEN_TEXTUREinto a variable calledpixelColorusing thetexture()function.\nthepixelColorvariable now holds the color of the current pixel, we\u0026rsquo;ll use it to calculate the brightness.\nStep 2: Calculate The Brightness there are two methods for calculating the pixel\u0026rsquo;s brightness:\naveraging the RGB channels dotting the RGB with the \u0026ldquo;Luma Coefficients\u0026rdquo; Method #1: RGB Avr. A pixel is made of a Red, Green and Blue channel and if all of them are equal then it\u0026rsquo;s not either Red, Green or Blue; it\u0026rsquo;s Grayscaled!\nthis method simply averages the red, green, and blue values of the pixel color to calculate the brightness of the pixel which will then be set to the RGB channels of the same pixel. This is a simpler and more straightforward method.\nfloat pixelBrightness = (pixelColor.r + pixelColor.g + pixelColor.b) / 3.0; Method #2: Luma Coeff This method uses the Dot Product of the pixel color (RGB vector) and the \u0026lsquo;Luma Coefficients\u0026rsquo; (a vector of weights R = 0.299, G = 0.587, B = 0.114) to calculate the pixel\u0026rsquo;s brightness. This method is based on the fact that the human eye is more sensitive to green light than to red or blue, so the weights are chosen to reflect this sensitivity. we can store the luma coefficients in a constant declared above our fragment function.\nconst vec3 LUMA_COEFFICIENTS = vec3(0.299, 0.587, 0.114); and then use it to calculate the pixel\u0026rsquo;s brightness.\nfloat pixelBrightness = dot(pixelColor.rgb, LUMA_COEFFICIENTS); Photometry is the science of measuring light in terms of its perceived brightness to the human eye. The human eye is most sensetive to green light, followed by red light, and least sensetive to blue light.\nif we average the RGB to calculate the pixel brightness, a completely blue pixelvec3(0.0, 0.0, 1.0)and a completely green pixelvec3(0.0, 1.0, 0.0)would both become(0.333, 0.333, 0.333)and they would look exactly the same, and therefore it would not be an accurate representation of how the human eye perceives brightness.\nThe luma coefficients work because they take into account the way the human eye perceives brightness. grayscaled with luma coefficients\ngrayscaled by averaging RGB\nleft: averaging RGB right:luma coefficients\npay attention to the light bulbs!\nStep 3: Grayscale The Pixel we compose a vector4 that haspixelBrightnessfor the RGB and1.0for the Alpha (full opacity).\nvec4 grayscale = vec4(vec3(pixelBrightness), 1.0); there\u0026rsquo;s quite a bit of flexibility in terms of syntax when it comes to composing vectors. if we pass only one scalar (numerical quantity) to the vector\u0026rsquo;s constructor, it will construct a vector that has the same scalar for all of the components(xyz\u0026hellip;), this is known as a uniform vector (DO NOT confuse with theuniformkeyword; they\u0026rsquo;re totally not the same thing!).vec3(pixelBrightness)would produce the same vector asvec3(pixelBrightness, pixelBrightness, pixelBrightness).\nyou can compose a vector by passing any combonation of vectors and scalars, for examplevec4(vec3(pixelBrightness), 1.0) and vec4(pixelBrightness, pixelBrightness, pixelBrightness, 1.0) would produce the same vector as well.\nnext we need to output this grayscaled pixel:\nCOLOR = grayscale; there\u0026rsquo;s a built-in variable in Godot shaders calledCOLORwhich is the currect pixel\u0026rsquo;s color.\nin some shading programs we might have to return the color but in Godot the fragment shader is avoidfunction.\nhere\u0026rsquo;s the final shader:\nshader_type canvas_item; uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap; uniform vec4 tint : source_color = vec4(0); const vec3 LUMA_COEFFICIENTS = vec3(0.299, 0.587, 0.114); void fragment() { vec4 pixelColor = texture(SCREEN_TEXTURE, SCREEN_UV); float pixelBrightness = dot(pixelColor.rgb, LUMA_COEFFICIENTS); vec4 grayscale = vec4(vec3(pixelBrightness), 1.0); COLOR = grayscale; } ","permalink":"http://localhost:1313/posts/grayscaling/","summary":"An image can be broken down into two components: the Chroma (Color) and the Luma (Brightness). if we desaturate an image completely (remove color), what is left is the Grayscaled version of that image. some people might refer to grayscale as \u0026ldquo;black and white\u0026rdquo;, however that\u0026rsquo;s not a technically accurate term for that. black and white would suggest that all the pixels of the image is either black or white, the image would be made of only 2 colors (Binary Image).","title":"Recipe 1: How To Grayscale The Screen"},{"content":" a red tinted vignette effect\nVignette is a technique used to draw the attention to the center of the image by darkening or blurring the corners or edges (towards the periphery) of the frame. this effect is often used to create a more dramatic or cinematic look.\nHow It Works? To create a vignette effect our fragment shader runs for every pixel and darkens it based on it\u0026rsquo;s distance from the center of the screen.\nThe Recipe Add a new ColorRect and make it Fullscreen and add a new ShaderMaterial to it and create a new shader for it (See How).\na new shader looks like this:\nshader_type canvas_item; void fragment() { // Place fragment code here. } We add the following line above thefragmentdefinition to declare a uniform that gives us access to the screen texture:\nuniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap; Step 1: Get Pixel\u0026rsquo;s Distance From Center TheSCREEN_UVis the current pixel\u0026rsquo;s uv coordinates. uv coorditates are between 0-1 and therefore the center of the screen would be at (0.5, 0.5) coordinates.\nwe get the distance of the current pixel from the center of the screen and store it in a variable calleddist.\nfloat dist = distance(SCREEN_UV, vec2(0.5, 0.5)); note that the calculated distance is not in pixels but instead a normalized(0-1) distance in uv coordinates. we could calculate the pixel position by multiplying the uv withSCREEN_PIXEL_SIZEbut we won\u0026rsquo;t cause we are going to use the distance as the interpolation factor and we need it to be normalized anyway.\nwe can usevec2(0.5)to get the center of the screen as well, the constructor will create a vec2 with 0.5 for both X and Y.\nStep 2: Vignette Mask Let\u0026rsquo;s add two properties for controlling the radius and sharpness of the vignette.\nuniform float sharpness; uniform float radius; Then we can use them in a smoothstep function to calculate the vignette mask value for this pixel.\nfloat vignette_mask = smoothstep(clamp(sharpness, 0, radius), radius, dist); smoothstep is a function that returns a smooth interpolation between a \u0026lsquo;min\u0026rsquo; and a \u0026lsquo;max\u0026rsquo; value based on the parameter(t). if we have the sharpness property to be 0 and the radius to be 1, the interpolation goes from the center of the screen to the very corners. if we set the sharpness to be close the the radius value, say 0.9, then the interpolation doesn\u0026rsquo;t start from the center of the screen but closer to the corners and therefore the vignette will become sharper.\nhowever we don\u0026rsquo;t want the sharpness value to be bigger than the radius since that would invert the interpolation (going from corners towards the center), so we clamp the sharpness to radius.\nStep 3: Darken The Screen Using The Mask We now can darken the current pixel based on the calculated mask. to do that we first sample the current pixel\u0026rsquo;s color into a variable called screen like this:\nvec4 screen = texture(SCREEN_TEXTURE, SCREEN_UV); And then we lerp it to vec4(0, 0, 0, 1) with the vignette mask as the interpolation factor (t parameter).\nscreen = mix(screen, vec4(0, 0, 0, 1), vignette_mask); We can then assign the calculated color to this pixel:\nCOLOR = screen; To be able to control the color of the vignette from the inspector, we can create a property for the shader called \u0026lsquo;vignette_color\u0026rsquo;:\nuniform vec4 vignette_color : source_color = vec4(0, 0, 0, 1); the source_color makes this vec4 show as a color in the material inspector.\nand we use that in the lerp instead:\nscreen = mix(screen, vignette_color, vignette_mask); Step 4: Vignette\u0026rsquo;s Shape We calculated the distance of each pixel to the center of the screen with UV coordinates. and because UV coordinates go between 0-1 the vignette\u0026rsquo;s shape will stretch to match the screen aspect ratio.\nthe distance from top to bottom, and left to right are both 1.0 and that\u0026rsquo;s why the mask that\u0026rsquo;s made with this UV will be stretched\nLet\u0026rsquo;s add a property to our shader that controls whether the vignette is circular or not(circle or oval).\nuniform bool circular = false; If we want the vignette to be a circle, we need to respect the aspect ratio when calculating the distance. we can calculate the aspect ratio like this:\nvec2 aspect_ratio = vec2(1.0, SCREEN_PIXEL_SIZE.x / SCREEN_PIXEL_SIZE.y); And now we can multiply theSCREEN_UVand the center coordinates (vec2(0.5)) with it if \u0026lsquo;circular\u0026rsquo; is true:\nfloat dist = 0.0; if(circular) dist = distance(SCREEN_UV * aspect_ratio, vec2(0.5) * aspect_ratio); else dist = distance(SCREEN_UV , vec2(0.5)); we can also write these lines shorter by getting the length of a vector going from center to the current pixel:\nfloat dist = 0.0; if(circular) dist = length((SCREEN_UV - vec2(0.5)) * vec2(1.0, SCREEN_PIXEL_SIZE.x/ SCREEN_PIXEL_SIZE.y)); else dist = length(SCREEN_UV - vec2(0.5)); we can further shorten in by using a ternary operator instead of an if else statement:\nfloat dist = circular? length((SCREEN_UV - vec2(0.5)) * aspect_ratio) : distance(SCREEN_UV , vec2(0.5)); keeping Height or Width? We can decide whether the height or the width changes to make the circular vignette effect respect the aspect ratio.\nkeep width not changing.\nvec2(SCREEN_PIXEL_SIZE.y/ SCREEN_PIXEL_SIZE.x, 1.0) keep height not changing\nvec2(1.0, SCREEN_PIXEL_SIZE.x/ SCREEN_PIXEL_SIZE.y) So now we can have another boolean property in our shader that toggles between these two expressions and assigns one of them to the \u0026lsquo;aspect_ratio\u0026rsquo; variable.\nuniform bool keep_height = true; Then we can use a ternary operator again to evaluate the aspect ratio:\nvec2 aspect_ratio = keep_height?vec2(SCREEN_PIXEL_SIZE.y / SCREEN_PIXEL_SIZE.x, 1.0) : vec2(1.0, SCREEN_PIXEL_SIZE.x / SCREEN_PIXEL_SIZE.y); when \u0026lsquo;keep_height\u0026rsquo; is not checked the circle\u0026rsquo;s height will change, but when it\u0026rsquo;s checked the height remains the same.\nhere\u0026rsquo;s the final shader:\nshader_type canvas_item; uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap; uniform float sharpness; uniform float radius; uniform bool circular = false; uniform bool keep_height = true; uniform vec4 vignette_color : source_color = vec4(0, 0, 0, 1); void fragment() { vec2 aspect_ratio = keep_height?vec2(SCREEN_PIXEL_SIZE.y / SCREEN_PIXEL_SIZE.x, 1.0) : vec2(1.0, SCREEN_PIXEL_SIZE.x / SCREEN_PIXEL_SIZE.y); float dist = circular? length((SCREEN_UV - vec2(0.5)) * aspect_ratio) : distance(SCREEN_UV , vec2(0.5)); float vigenette_mask = smoothstep(clamp(sharpness, 0, radius), radius, dist); vec4 screen = texture(SCREEN_TEXTURE, SCREEN_UV); screen = mix(screen, vignette_color, vigenette_mask); COLOR = screen; } ","permalink":"http://localhost:1313/posts/vignette/","summary":"a red tinted vignette effect\nVignette is a technique used to draw the attention to the center of the image by darkening or blurring the corners or edges (towards the periphery) of the frame. this effect is often used to create a more dramatic or cinematic look.\nHow It Works? To create a vignette effect our fragment shader runs for every pixel and darkens it based on it\u0026rsquo;s distance from the center of the screen.","title":"Recipe 2: How To Create Vignette"}]